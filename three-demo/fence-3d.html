<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>fence-3d</title>
    <script type="text/javascript" src="./js/three.js"></script>
<style>
	*{
		margin: 0;
		padding: 0;
	}
</style>
</head>
<body>
	</body>
	<script>
		// 场景 模型 光源 相机 渲染器
		var vertexShader = [
    'varying vec3	vVertexWorldPosition;',
    'varying vec3	vVertexNormal;',
    'varying vec4	vFragColor;',
    'void main(){',
    '	vVertexNormal	= normalize(normalMatrix * normal);',//将法线转换到视图坐标系中
    '	vVertexWorldPosition	= (modelMatrix * vec4(position, 1.0)).xyz;',//将顶点转换到世界坐标系中
    '	// set gl_Position',
    '	gl_Position	= projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
    '}'
		].join('\n');

		THREE.GlowSphere = {
    uniforms: {
        coeficient: {
            type: "f",
            value: 0.0
        },
        power: {
            type: "f",
            value: 2
        },
        glowColor: {
            type: "c",
            value: new THREE.Color(0x000000)
        }
    },
    vertexShader: vertexShader,
    fragmentShader: [
        'uniform vec3	glowColor;',
        'uniform float	coeficient;',
        'uniform float	power;',

        'varying vec3	vVertexNormal;',
        'varying vec3	vVertexWorldPosition;',

        'varying vec4	vFragColor;',

        'void main(){',
        '	vec3 worldVertexToCamera= cameraPosition - vVertexWorldPosition;',	//世界坐标系中顶点位置到相机位置到的距离
        '	vec3 viewCameraToVertex	= (viewMatrix * vec4(worldVertexToCamera, 0.0)).xyz;',//视图坐标系中从相机位置到顶点位置的距离
        '	viewCameraToVertex	= normalize(viewCameraToVertex);',//规一化
        '	float intensity		= coeficient + dot(vVertexNormal, viewCameraToVertex);',
        '	if(intensity > 0.65){ intensity = 0.0;}',
        '	gl_FragColor		= vec4(glowColor, intensity);',
        '}'//vVertexNormal视图坐标系中点的法向量
        //viewCameraToVertex视图坐标系中点到摄像机的距离向量
        //dot点乘得到它们的夹角的cos值
        //从中心向外面角度越来越大（从锐角到钝角）从cos函数也可以知道这个值由负变正，不透明度最终从高到低
    ].join('\n')
	}

		let scene = new THREE.Scene();
    function createLine(t, h, c) {
  		let geometry = new THREE.Geometry();
      let p1 = new THREE.Vector3(-t,h,t);
      let p2 = new THREE.Vector3(t,h,t);
      let p3 = new THREE.Vector3(t,h,-t);
      let p4 = new THREE.Vector3(-t,h,-t);
      let p5 = new THREE.Vector3(-t,h,t);
      geometry.vertices.push(p1,p2,p3,p4,p5);
      let meterial = new THREE.MeshLambertMaterial({
        color: c
			});
			let meterial2 =  new THREE.ShaderMaterial({
            uniforms: THREE.GlowSphere.uniforms,
            vertexShader: THREE.GlowSphere.vertexShader,
            fragmentShader: THREE.GlowSphere.fragmentShader,
            blending: THREE.NormalBlending,
            transparent: true
        })
			let mesh = new THREE.Line(geometry, meterial);
			let lightMesh = new THREE.Line(geometry, meterial2);
			scene.add(lightMesh);
      return mesh
    }
    
		scene.add(createLine(100, 0, '#0000FF'));
		scene.add(createLine(100, 5, '#1717FF'));
		scene.add(createLine(100, 10, '#2E2EFF'));
		scene.add(createLine(100, 15, '#4646FF'));
		scene.add(createLine(100, 20, '#5D5DFF'));
		scene.add(createLine(100, 25, '#7474FF'));
		scene.add(createLine(100, 30, '#8B8BFF'));
		scene.add(createLine(100, 35, '#A2A2FF'));
		scene.add(createLine(100, 40, '#B9B9FF'));
		scene.add(createLine(100, 45, '#D1D1FF'));


		let light = new THREE.AmbientLight('#FFFFFF');
		scene.add(light);

		let width = window.innerWidth;
		let height = window.innerHeight;
		let camera = new THREE.PerspectiveCamera(50, width / height, 1, 1000);
		camera.position.set(200, 300, 200);
		camera.lookAt(scene.position);
		
		let axesHelper = new THREE.AxesHelper( 50 );
		scene.add( axesHelper );

		let renderer = new THREE.WebGLRenderer();
		renderer.setSize(width, height);
		renderer.setClearColor('#000000', 1);
		document.body.appendChild(renderer.domElement);
		// renderer.render(scene, camera);
		// 渲染函数
		function render() {
				renderer.render(scene,camera);//执行渲染操作
				// mesh.rotateY(0.01);//每次绕y轴旋转0.01弧度
		}
		//间隔20ms周期性调用函数fun,20ms也就是刷新频率是50FPS(1s/20ms)，每秒渲染50次
		setInterval(render,20);
	</script>
</html>